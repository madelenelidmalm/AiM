from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime, Float, ForeignKey
from sqlalchemy.orm import sessionmaker, relationship, Session
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime, timedelta
from jose import JWTError, jwt
import os
from typing import List, Optional
from pydantic import BaseModel, EmailStr, Field  # Import Pydantic
from passlib.context import CryptContext  # For password hashing


# --- Configuration ---
DATABASE_URL = os.environ.get("DATABASE_URL", "postgresql://user:password@localhost/dbname")
SECRET_KEY = os.environ.get("SECRET_KEY", "your-super-secret-key")  # Secure this!
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# --- Database Setup ---
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# --- Pydantic Models (for request/response validation) ---

class UserCreate(BaseModel):
    email: EmailStr
    password: str

class User(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

class Grant(BaseModel):
    id: int
    name: str
    description: str
    deadline: datetime
    funding_amount: float

    class Config:
        orm_mode = True

class ApplicationCreate(BaseModel):
    grant_id: int

class Application(BaseModel):
    id: int
    user_id: int
    grant_id: int
    status: str
    submitted_at: datetime

    class Config:
        orm_mode = True
        
class Token(BaseModel):
    access_token: str
    token_type: str

class Reminder(BaseModel):
    grant_name: str
    deadline: datetime


# --- Database Models ---
class DBUser(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    applications = relationship("DBApplication", back_populates="user")

class DBGrant(Base):
    __tablename__ = "grants"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    description = Column(Text, nullable=False)
    deadline = Column(DateTime, nullable=False)
    funding_amount = Column(Float, nullable=False)
    applications = relationship("DBApplication", back_populates="grant")

class DBApplication(Base):
    __tablename__ = "applications"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    grant_id = Column(Integer, ForeignKey("grants.id"), nullable=False)
    status = Column(String, default="pending")
    submitted_at = Column(DateTime, default=datetime.utcnow)
    user = relationship("DBUser", back_populates="applications")
    grant = relationship("DBGrant", back_populates="applications")

# --- FastAPI Setup ---
app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# --- Database Dependency ---
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- Authentication ---
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        user = db.query(DBUser).filter(DBUser.id == int(user_id)).first() # Convert to int
        if user is None:
            raise credentials_exception
        return user
    except JWTError:
        raise credentials_exception
    except ValueError:  # Handle potential ValueError if user_id is not an integer
        raise credentials_exception

# --- Password Hashing ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password):
    return pwd_context.hash(password)

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

# --- API Endpoints ---

@app.post("/token", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = db.query(DBUser).filter(DBUser.email == form_data.username).first()
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": str(user.id)}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/users/", response_model=User)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    existing_user = db.query(DBUser).filter(DBUser.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed_password = get_password_hash(user.password)
    db_user = DBUser(email=user.email, hashed_password=hashed_password)
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@app.get("/users/me/", response_model=User)
async def read_users_me(current_user: DBUser = Depends(get_current_user)):
    return current_user

@app.get("/grants/", response_model=List[Grant])
async def read_grants(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    grants = db.query(DBGrant).offset(skip).limit(limit).all()
    return grants

@app.post("/applications/", response_model=Application)
async def create_application(application: ApplicationCreate, current_user: DBUser = Depends(get_current_user), db: Session = Depends(get_db)):
    db_application = DBApplication(user_id=current_user.id, grant_id=application.grant_id)
    db.add(db_application)
    db.commit()
    db.refresh(db_application)
    return db_application

@app.get("/reminders/", response_model=List[Reminder])
async def get_reminders(current_user: DBUser = Depends(get_current_user), db: Session = Depends(get_db)):
    upcoming_deadlines = db.query(DBGrant).filter(DBGrant.deadline >= datetime.utcnow()).filter(DBGrant.deadline <= datetime.utcnow() + timedelta(days=7)).all()
    reminders = [{"grant_name": g.name, "deadline": g.deadline} for g in upcoming_deadlines]
    return reminders

# --- Create Tables (Run Once, and correctly) ---
def create_tables():
    Base.metadata.create_all(bind=engine)

if __name__ == "__main__":
    create_tables()  # Call the function to create tables
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000) # Use 0.0.0.0 to listen on all interfaces
